import os
import shutil

from babelapi.generator.generator import CodeGeneratorMonolingual
from contextlib import contextmanager

from babelapi.data_type import (
    DataType,
    Float32,
    Float64,
    Int32,
    Int64,
    UInt32,
    UInt64,
    is_any_type,
    is_binary_type,
    is_boolean_type,
    is_composite_type,
    is_list_type,
    is_null_type,
    is_string_type,
    is_struct_type,
    is_symbol_type,
    is_timestamp_type,
    is_union_type,
    is_numeric_type,
)

from babelapi.lang.swift import SwiftTargetLanguage

base = """
/* Autogenerated. Do not edit. */
import Foundation
import SwiftyJSON

"""

class SwiftGenerator(CodeGeneratorMonolingual):
    lang = SwiftTargetLanguage()

    def generate(self):
        cur_folder = os.path.dirname(__file__)
        self._logger.info('Copying babel_serializers.swift to output folder')
        shutil.copy(os.path.join(cur_folder, 'babel_serializers.swift'),
                    self.target_folder_path)

        self._logger.info('Copying babel_validators.swift to output folder')
        shutil.copy(os.path.join(cur_folder, 'babel_validators.swift'),
                    self.target_folder_path)

        self._logger.info('Copying Dropbox.swift to output folder')
        shutil.copy(os.path.join(cur_folder, 'Dropbox.swift'),
                    self.target_folder_path)

        for namespace in self.api.namespaces.values():
            with self.output_to_relative_path('{}.swift'.format(namespace.name)):
                self._generate_base_namespace_module(namespace)


    def _generate_base_namespace_module(self, namespace):
        self.emit(base)

        with self.block('public class {}'.format(self.lang.format_class(namespace.name))):
            for data_type in namespace.linearize_data_types():
                if is_struct_type(data_type):
                    self._generate_struct_class(namespace, data_type)
                elif is_union_type(data_type):
                    self._generate_union_type(namespace, data_type)
#            else:
#                raise TypeError('Cannot handle type %r' % type(data_type))
        self._generate_routes(namespace)

    # generation helper methods

    @contextmanager
    def function_block(self, func, args, return_type=None):
        signature = '{}({})'.format(func, args)
        if return_type:
            signature += '-> {}'.format(return_type)
        with self.block(signature):
            yield

    def _func_args(self, args_list, newlines=False, force_first=False):
        out = []
        first = True
        for k, v in args_list:
            if first and force_first:
                k = "#"+k
            if v is not None:
                out.append('{}: {}'.format(k, v))
            first = False
        sep = ', '
        if newlines:
            sep += '\n' + self.make_indent()
        return sep.join(out)

    @contextmanager
    def class_block(self, thing, protocols=None):
        protocols = protocols or []
        extensions = []

        if isinstance(thing, DataType):
            name = self.class_data_type(thing)
            if thing.super_type:
                extensions.append(self.class_data_type(thing.super_type))
        elif isinstance(thing, basestring):
            name = thing
        else:
            raise TypeError("trying to generate class block for unknown type %r" % thing)

        extensions.extend(protocols)

        extend_suffix = ': {}'.format(', '.join(extensions)) if extensions else ''

        with self.block('public class {}{}'.format(name, extend_suffix)):
            yield

    @contextmanager
    def serializer_block(self, data_type):
        with self.class_block(self.class_data_type(data_type)+'Serializer', protocols=['JSONSerializer']):
            self.emit_line("public init() { }")
            yield

    @contextmanager
    def serializer_func(self, data_type):
        with self.function_block('public func serialize',
                                 args=self._func_args([('value', self.class_data_type(data_type))]),
                                 return_type='String?'):
            yield

    @contextmanager
    def deserializer_func(self, data_type):
        with self.function_block('public func deserialize',
                                 args=self._func_args([('json', 'JSON')]),
                                 return_type=self.class_data_type(data_type)):
            yield

    def class_data_type(self, data_type):
        return self.lang.format_class(data_type.name)

    def _serializer_type(self, data_type, namespace=None):
        if is_list_type(data_type):
            ret = 'ArraySerializer({})'.format(
                self._serializer_type(data_type.data_type, namespace=namespace)
            )
        elif is_string_type(data_type):
            ret = 'Serialization._StringSerializer'
        elif is_timestamp_type(data_type):
            ret = 'NSDateSerializer("{}")'.format(data_type.format)
        elif is_boolean_type(data_type):
            ret = 'Serialization._BoolSerializer'
        elif isinstance(data_type, Int32):
            ret = 'Serialization._Int32Serializer'
        elif isinstance(data_type, Int64):
            ret = 'Serialization._Int64Serializer'
        elif isinstance(data_type, UInt32):
            ret = 'Serialization._UInt32Serializer'
        elif isinstance(data_type, UInt64):
            ret = 'Serialization._UInt64Serializer'
        elif isinstance(data_type, Float32):
            ret = 'Serialization._Float32Serializer'
        elif isinstance(data_type, Float64):
            ret = 'Serialization._Float64Serializer'
        elif is_composite_type(data_type):
            ret = self.lang.format_class(namespace.name) + '.' if namespace else ''
            ret += self.class_data_type(data_type) + 'Serializer()'

        if data_type.nullable:
            ret = 'NullableSerializer({})'.format(ret)

        return ret

    def _swift_type_mapping(self, data_type, namespace=None):
        if is_list_type(data_type):
            ret = 'Array<{}>'.format(
                self._swift_type_mapping(data_type.data_type)
            )
        elif is_string_type(data_type):
            ret = 'String'
        elif is_timestamp_type(data_type):
            ret = 'NSDate'
        elif is_boolean_type(data_type):
            ret = 'Bool'
        elif isinstance(data_type, Int32):
            ret = 'Int32'
        elif isinstance(data_type, Int64):
            ret = 'Int64'
        elif isinstance(data_type, UInt32):
            ret = 'UInt32'
        elif isinstance(data_type, UInt64):
            ret = 'UInt64'
        elif isinstance(data_type, Float32):
            ret = 'Float'
        elif isinstance(data_type, Float64):
            ret = 'Double'
        elif is_composite_type(data_type):
            ret = self.lang.format_class(namespace.name) + "." if namespace else ""
            ret += self.class_data_type(data_type)
        if data_type.nullable:
            ret += '?'
        return ret

    def _determine_validator_type(self, data_type):
        if is_list_type(data_type):
            item_validator = self._determine_validator_type(data_type.data_type)
            if item_validator:
                v = "ArrayValidator({})".format(
                    self._func_args([
                        ("itemValidator", item_validator),
                        ("minItems", data_type.min_items),
                        ("maxItems", data_type.max_items),
                    ])
                )
            else:
                return None
        elif is_numeric_type(data_type):
            v = "ComparableTypeValidator({})".format(
                self._func_args([
                    ("minValue", data_type.min_value),
                    ("maxValue", data_type.max_value),
                ])
            )
        elif is_string_type(data_type):
            v = "StringValidator({})".format(
                self._func_args([
                    ("minLength", data_type.min_length),
                    ("maxLength", data_type.max_length),
                    ("pattern", repr(data_type.pattern) if data_type.pattern else None),
                ])
            )
        else:
            return None

        if data_type.nullable:
            v = "NullableValidator({})".format(v)
        return v

    def _generate_struct_class(self, namespace, data_type):
        with self.class_block(data_type):
            for field in data_type.fields:
                self.emit_line('public let {} : {}'.format(
                    self.lang.format_variable(field.name),
                    self._swift_type_mapping(field.data_type),
                ))
            self._generate_struct_init(namespace, data_type)

        self._generate_struct_class_serializer(data_type)

    def _struct_init_args(self, data_type, namespace=None):
        args = []
        for field in data_type.all_fields:
            name = self.lang.format_variable(field.name)
            value = self._swift_type_mapping(field.data_type, namespace=namespace)
            if field.has_default:
                value += ' = {}'.format(self.lang.format_obj(field.default))
            arg = (name, value)
            args.append(arg)
        return args

    def _generate_struct_init(self, namespace, data_type):
        # init method
        args = self._struct_init_args(data_type)
        with self.function_block('public init', self._func_args(args, newlines=True)):
            for field in data_type.fields:
                v = self.lang.format_variable(field.name)
                validator = self._determine_validator_type(field.data_type)
                if validator:
                    self.emit_line('{}.validate({})'.format(validator, v))
                self.emit_line('self.{} = {}'.format(v, v))
            if data_type.super_type:
                self.emit_line('super.init', trailing_newline=False)
                self._generate_func_arg_list(['{}: {}'.format(self.lang.format_variable(f.name),
                                                              self.lang.format_variable(f.name))
                                              for f in data_type.super_type.fields])
                self.emit_empty_line()

    def _generate_struct_class_serializer(self, data_type):
        with self.serializer_block(data_type):
            with self.serializer_func(data_type):
                self.emit_line("var output : [String] = []")
                for field in data_type.all_fields:
                    self.emit_line('Serialization.addOutput({})'.format(self._func_args([
                        ("field", '"'+field.name+'"'),
                        ("value", "value."+self.lang.format_variable(field.name)),
                        ("serializer", self._serializer_type(field.data_type)),
                        ("output", "&output"),
                    ])))
                self.emit_line('return "{"+", ".join(output)+"}"')
            with self.deserializer_func(data_type):
                args = []
                for field in data_type.all_fields:
                    var = self.lang.format_variable(field.name)
                    self.emit_line('let {} = {}.deserialize(json["{}"])'.format(
                        var,
                        self._serializer_type(field.data_type),
                        field.name,
                    ))

                    args.append((var, var))
                self.emit_line('return {}({})'.format(
                    self.class_data_type(data_type),
                    self._func_args(args)
                ))

    def _format_tag_type(self, namespace, data_type):
        if is_symbol_type(data_type) or is_any_type(data_type):
            return ''
        else:
            return '({})'.format(self._swift_type_mapping(data_type, namespace))

    def _generate_union_type(self, namespace, data_type):
        with self.block('public enum {}'.format(self.class_data_type(data_type))):
            for field in data_type.fields:
                typ = self._format_tag_type(namespace, field.data_type)
                self.emit_line('case {}{}'.format(self.lang.format_class(field.name),
                                                  typ))

        self._generate_union_serializer(data_type)

    def _generate_union_serializer(self, data_type):
        class_name = self.class_data_type(data_type)
        with self.serializer_block(data_type):
            with self.serializer_func(data_type):
                with self.block('switch value'):
                    for field in data_type.fields:
                        case = '.{}'.format(self.lang.format_class(field.name))
                        if is_symbol_type(field.data_type) or is_any_type(field.data_type):
                            ret = '"\\"{}\\""'.format(field.name)
                        else:
                            case += '(let arg)'
                            ret = "Serialization.output({})".format(self._func_args([
                                ("field", '"{}"'.format(field.name)),
                                ("value", "arg"),
                                ("serializer", self._serializer_type(field.data_type)),
                            ]))
                        self.emit_line('case {}:'.format(case))
                        with self.indent():
                            self.emit_line('return {}'.format(ret))
            with self.deserializer_func(data_type):
                composites = []
                symbols = []


                for field in data_type.fields:
                    if is_symbol_type(field.data_type) or is_any_type(field.data_type):
                        ret = "return {}.{}".format(
                            self.class_data_type(data_type),
                            self.lang.format_class(field.name)
                        )
                        symbols.append( (field.name, ret) )
                    else:
                        serializer = self._serializer_type(field.data_type)
                        composites.append( (field.name, serializer) )
                if symbols:
                    with self.block('if let str = json.string'):
                        with self.block('switch str'):
                            for case, ret in symbols:
                                self.emit_line('case "{}":'.format(case))
                                with self.indent():
                                    self.emit_line(ret)
                            self.emit_line('default:')
                            with self.indent():
                                self.emit_line('assert(false, "Invalid tag \\"\\(str)\\"")')
                if composites:
                    prefix = 'else ' if symbols else ''
                    with self.block('{}if let d = json.dictionary'.format(prefix)):
                        self.emit_line('assert(d.count == 1, "Expected 1 key, got \\(d.count)")')

                        with self.block('for (key, val) in d'), self.block('switch key'):
                            for f, serializer in composites:
                                self.emit_line('case "{}":'.format(f))
                                with self.indent():
                                    self.emit_line('let obj = {}.deserialize(val)'.format(serializer))
                                    self.emit_line('return {}.{}(obj)'.format(
                                        self.class_data_type(data_type),
                                        self.lang.format_class(f),
                                    ))
                            self.emit_line('default:')
                            with self.indent():
                                self.emit_line('assert(false, "Invalid tag \\"\\(key)\\"")')
                self.emit_line('assert(false, "Failed to deserialize")')
    def _generate_routes(self, namespace):
        with self.block('extension DropboxClient'):
            for route in namespace.routes:
                self._generate_route(namespace, route)

    def _generate_route(self, namespace, route):
        host_ident = route.attrs.get('host', 'meta')

        request_type = self._swift_type_mapping(route.request_data_type, namespace=namespace)
        response_type = self._swift_type_mapping(route.response_data_type, namespace=namespace)
        error_type = self._swift_type_mapping(route.error_data_type, namespace=namespace)

        #func runRequest<RType: JSONSerializer, EType: JSONSerializer>(
        ##host: String,
        #route: String,
        #params: String,
        #responseSerializer: RType,
        #errorSerializer: EType,
        #completionHandler: RequestResult<RType.ValueType, EType.ValueType> -> Void) {
        if is_struct_type(route.request_data_type):
            arg_list = self._struct_init_args(route.request_data_type, namespace=namespace)
        else:
            arg_list = [('request', request_type)]

        arg_list.append(
            ("completionHandler", "({}?, CallError<{}>?) -> Void".format(response_type, error_type))
        )

        func_name = self.lang.format_method('{}_{}'.format(namespace.name, route.name))
        with self.function_block('public func {}'.format(func_name), args=self._func_args(arg_list, force_first=True)):

            if is_struct_type(route.request_data_type):
                constructor_args = [(name, name) for name, value in self._struct_init_args(route.request_data_type)]
                self.emit_line('let request = {}({})'.format(request_type, self._func_args(constructor_args)))

            self.emit_line('self.runRequest({})'.format(self._func_args([
                ('host', '"'+host_ident+'"'),
                ('route', '"/{}/{}"'.format(namespace.name, route.name)),
                ('params', '{}.serialize(request)'.format(self._serializer_type(route.request_data_type, namespace=namespace))),
                ('responseSerializer', self._serializer_type(route.response_data_type, namespace=namespace)),
                ('errorSerializer', self._serializer_type(route.error_data_type, namespace=namespace)),
                ('completionHandler', 'completionHandler')
            ])))
