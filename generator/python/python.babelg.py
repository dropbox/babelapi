"""
Code generator for Python.
"""

from __future__ import absolute_import, division, print_function, unicode_literals

import os
import re
import shutil
from babelapi.data_type import (
    is_binary_type,
    is_boolean_type,
    is_composite_type,
    is_float_type,
    is_integer_type,
    is_list_type,
    is_numeric_type,
    is_string_type,
    is_struct_type,
    is_tag_ref,
    is_timestamp_type,
    is_union_type,
    is_void_type,
)
from babelapi.generator import CodeGeneratorMonolingual
from babelapi.lang.python import PythonTargetLanguage

# This will be at the top of every generated file.
base = """\
# Auto-generated by BabelAPI, do not modify.
try:
    from . import babel_validators as bv
except (SystemError, ValueError):
    # Catch errors raised when importing a relative module when not in a package.
    # This makes testing this file directly (outside of a package) easier.
    import babel_validators as bv

"""

# Matches format of Babel doc tags
doc_sub_tag_re = re.compile(':(?P<tag>[A-z]*):`(?P<val>.*?)`')

class PythonGenerator(CodeGeneratorMonolingual):
    """Generates Python modules to represent the input Babel spec."""

    lang = PythonTargetLanguage()

    def generate(self, api):
        """
        Generates a module for each namespace.

        Each namespace will have Python classes to represent data types and
        routes in the Babel spec.
        """
        cur_folder = os.path.dirname(__file__)
        self.logger.info('Copying babel_validators.py to output folder')
        shutil.copy(os.path.join(cur_folder, 'babel_validators.py'),
                    self.target_folder_path)
        self.logger.info('Copying babel_serializers.py to output folder')
        shutil.copy(os.path.join(cur_folder, 'babel_serializers.py'),
                    self.target_folder_path)
        for namespace in api.namespaces.values():
            with self.output_to_relative_path('{}.py'.format(namespace.name)):
                self._generate_base_namespace_module(namespace)

    def _generate_base_namespace_module(self, namespace):
        """Creates a module for the namespace. All data types and routes are
        represented as Python classes."""
        self.emit_raw(base)
        for data_type in namespace.linearize_data_types():
            if is_struct_type(data_type):
                self._generate_struct_class(data_type)
            elif is_union_type(data_type):
                self._generate_union_class(data_type)
            else:
                raise TypeError('Cannot handle type %r' % type(data_type))

    def _docf(self, tag, val):
        """
        Callback used as the handler argument to process_docs(). This converts
        Babel doc references to Sphinx-friendly annotations.
        """
        if tag == 'type':
            return ':class:`{}`'.format(val)
        elif tag == 'route':
            # TODO(kelkabany): This generator doesn't generate methods for
            # routes. But, for a generator that does, it would be nice to
            # override this to make it reference the proper method.
            return val
        elif tag == 'link':
            anchor, link = val.rsplit(' ', 1)
            return '`{} <{}>`_'.format(anchor, link)
        elif tag == 'val':
            if val == 'null':
                return 'None'
            elif val == 'true' or val == 'false':
                return val.capitalize()
            else:
                return val
        elif tag == 'field':
            return '``{}``'.format(val)
        else:
            raise RuntimeError('Unknown doc ref tag %r' % tag)

    def _python_type_mapping(self, data_type):
        """Map Babel data types to their most natural equivalent in Python
        for documentation purposes."""
        if is_string_type(data_type):
            return 'str'
        elif is_binary_type(data_type):
            return 'str'
        elif is_boolean_type(data_type):
            return 'bool'
        elif is_float_type(data_type):
            return 'float'
        elif is_integer_type(data_type):
            return 'long'
        elif is_void_type(data_type):
            return 'None'
        elif is_timestamp_type(data_type):
            return 'datetime.datetime'
        elif is_composite_type(data_type):
            return self._class_name_for_data_type(data_type)
        elif is_list_type(data_type):
            # PyCharm understands this description format for a list
            return 'list of [{}]'.format(self._python_type_mapping(data_type.data_type))
        else:
            raise TypeError('Unknown data type %r' % data_type)

    def _class_name_for_data_type(self, data_type):
        assert is_composite_type(data_type), \
            'Expected composite type, got %r' % type(data_type)
        return self.lang.format_class(data_type.name)

    #
    # Struct Types
    #

    def _class_declaration_for_struct(self, data_type):
        assert is_struct_type(data_type), \
            'Expected struct, got %r' % type(data_type)
        if data_type.supertype:
            extends = self._class_name_for_data_type(data_type.supertype)
        else:
            extends = 'object'
        return 'class {}({}):'.format(
            self._class_name_for_data_type(data_type), extends)

    def _generate_struct_class(self, data_type):
        """Defines a Python class that represents a struct in Babel."""
        self.emit(self._class_declaration_for_struct(data_type))
        with self.indent():
            if data_type.doc:
                self.emit('"""')
                self.emit_wrapped_text(
                    self.process_doc(data_type.doc, self._docf))
                self.emit()
                for field in data_type.fields:
                    if field.doc:
                        self.emit_wrapped_text(':ivar {}: {}'.format(
                            self.lang.format_variable(field.name),
                            self.process_doc(field.doc, self._docf)),
                            subsequent_prefix='    ')
                self.emit('"""')
            self.emit()

            self._generate_struct_class_slots(data_type)
            self._generate_struct_class_vars(data_type)
            self._generate_struct_class_init(data_type)
            self._generate_struct_class_properties(data_type)
            self._generate_struct_class_repr(data_type)

    def _func_args_from_dict(self, d):
        """Given a Python dictionary, creates a string representing arguments
        for invoking a function. All arguments with a value of None are
        ignored."""
        filtered_d = self.filter_out_none_valued_keys(d)
        return ', '.join(['%s=%s' % (k, v) for k, v in filtered_d.items()])

    def _generate_struct_class_slots(self, data_type):
        """Creates a slots declaration for struct classes.

        Slots are an optimization in Python. They reduce the memory footprint
        of instances since attributes cannot be added after declaration.
        """
        with self.block('__slots__ =', delim=('[', ']')):
            for field in data_type.fields:
                field_name = self.lang.format_variable(field.name)
                self.emit("'_%s_value'," % field_name)
                self.emit("'_%s_present'," % field_name)
        self.emit()

    def _generate_struct_class_vars(self, data_type):
        """
        Each class has a class attribute for each field. The attribute is a
        validator for the field.
        """
        lineno = self.lineno
        for field in data_type.fields:
            field_name = self.lang.format_variable(field.name)
            validator_name = self._generate_validator_constructor(field.data_type)
            self.emit('_{}_validator = {}'.format(field_name,
                                                  validator_name))
        if lineno != self.lineno:
            self.emit()

        self._generate_struct_class_fields_for_reflection(data_type)

    def _generate_validator_constructor(self, data_type):
        """
        Given a Babel data type, returns a string that can be used to construct
        the appropriate validation object in Python.
        """
        if is_list_type(data_type):
            v = self._generate_func_call(
                'bv.List',
                args=[
                    self._generate_validator_constructor(data_type.data_type)],
                kwargs=[
                    ('min_items', data_type.min_items),
                    ('max_items', data_type.max_items)],
            )
        elif is_numeric_type(data_type):
            v = self._generate_func_call(
                'bv.{}'.format(data_type.name),
                kwargs=[
                    ('min_value', data_type.min_value),
                    ('max_value', data_type.max_value)],
            )
        elif is_string_type(data_type):
            pattern = None
            if data_type.pattern is not None:
                pattern = repr(data_type.pattern)
            v = self._generate_func_call(
                'bv.String',
                kwargs=[
                    ('min_length', data_type.min_length),
                    ('max_length', data_type.max_length),
                    ('pattern', pattern)],
            )
        elif is_timestamp_type(data_type):
            v = self._generate_func_call(
                'bv.Timestamp',
                args=[repr(data_type.format)],
            )
        elif is_struct_type(data_type):
            v = self._generate_func_call(
                'bv.Struct',
                args=[self.lang.format_class(data_type.name)],
            )
        elif is_union_type(data_type):
            v = self._generate_func_call(
                'bv.Union',
                args=[self.lang.format_class(data_type.name)],
            )
        else:
            v = self._generate_func_call('bv.{}'.format(data_type.name))
        if data_type.nullable:
            return self._generate_func_call('bv.Nullable', args=[v])
        else:
            return v

    @classmethod
    def _generate_func_call(cls, name, args=None, kwargs=None):
        """
        Generates code to call a function.

        Args:
            name (str): The function name.
            args (list[str]): Each positional argument.
            kwargs (list[tuple]): Each tuple is (arg: str, value: str). If
                value is None, then the keyword argument is omitted. Otherwise,
                if the value is not a string, then str() is called on it.

        Returns:
            str: Code to call a function.
        """
        all_args = []
        if args:
            all_args.extend(args)
        if kwargs:
            all_args.extend('{}={}'.format(k, v)
                            for k, v in kwargs if v is not None)
        return '{}({})'.format(name, ', '.join(all_args))

    def _generate_struct_class_fields_for_reflection(self, data_type):
        """
        Declares a _field_names_ class attribute, which is a set of all field
        names. Also, declares a _fields_ class attribute which is a list of
        tuples, where each tuple is (field name, validator).
        """
        if data_type.supertype:
            supertype_class_name = self._class_name_for_data_type(data_type.supertype)
        else:
            supertype_class_name = None

        if supertype_class_name:
            self.emit('_field_names_ = %s._field_names_.union(set((' %
                           supertype_class_name)
        else:
            self.emit('_field_names_ = set((')
        with self.indent():
            for field in data_type.fields:
                self.emit("'{}',".format(self.lang.format_variable(field.name)))

        if supertype_class_name:
            self.emit(')))')
        else:
            self.emit('))')
        self.emit()

        if supertype_class_name:
            self.emit('_fields_ = {}._fields_ + ['.format(supertype_class_name))
        else:
            self.emit('_fields_ = [')

        with self.indent():
            for field in data_type.fields:
                var_name = self.lang.format_variable(field.name)
                validator_name = '_{0}_validator'.format(var_name)
                self.emit("('{}', {}),".format(var_name, validator_name))
        self.emit(']')
        self.emit()

    def _generate_struct_class_init(self, data_type):
        """
        Generates constructor. The constructor takes all possible fields as
        optional arguments. Any argument that is set on construction sets the
        corresponding field for the instance.
        """
        args = ['self']
        for field in data_type.all_fields:
            field_name_reserved_check = self.lang.format_variable(field.name, True)
            args.append('%s=None' % field_name_reserved_check)
        self.generate_multiline_list(args, before='def __init__', after=':')

        with self.indent():
            lineno = self.lineno

            # Call the parent constructor if a super type exists
            if data_type.supertype:
                class_name = self._class_name_for_data_type(data_type)
                self.generate_multiline_list(
                    [self.lang.format_method(f.name, True)
                     for f in data_type.supertype.all_fields],
                    before='super({}, self).__init__'.format(class_name))

            # initialize each field
            for field in data_type.fields:
                field_var_name = self.lang.format_variable(field.name)
                self.emit('self._{}_value = None'.format(field_var_name))
                self.emit('self._{}_present = False'.format(field_var_name))

            # handle arguments that were set
            for field in data_type.fields:
                field_var_name = self.lang.format_variable(field.name, True)
                self.emit('if {} is not None:'.format(field_var_name))
                with self.indent():
                    self.emit('self.{0} = {0}'.format(field_var_name))

            if lineno == self.lineno:
                self.emit('pass')
            self.emit()

    def _generate_python_value(self, value):
        if is_tag_ref(value):
            return '{}.{}'.format(
                self._class_name_for_data_type(value.union_data_type),
                self.lang.format_variable(value.tag_name))
        else:
            return self.lang.format_obj(value)

    def _generate_struct_class_properties(self, data_type):
        """
        Each field of the struct has a corresponding setter and getter.
        The setter validates the value being set.
        """
        for field in data_type.fields:
            field_name = self.lang.format_method(field.name)
            field_name_reserved_check = self.lang.format_method(field.name, True)

            # generate getter for field
            self.emit('@property')
            self.emit('def {}(self):'.format(field_name_reserved_check))
            with self.indent():
                self.emit('"""')
                if field.doc:
                    self.emit_wrapped_text(
                        self.process_doc(field.doc, self._docf))
                    # Sphinx wants an extra line between the text and the
                    # rtype declaration.
                    self.emit()
                self.emit(':rtype: {}'.format(
                    self._python_type_mapping(field.data_type)))
                self.emit('"""')
                self.emit('if self._{}_present:'.format(field_name))
                with self.indent():
                    self.emit('return self._{}_value'.format(field_name))

                self.emit('else:')
                with self.indent():
                    if field.data_type.nullable:
                        self.emit('return None')
                    elif field.has_default:
                        self.emit('return {}'.format(
                            self._generate_python_value(field.default)))
                    else:
                        self.emit(
                            "raise AttributeError(\"missing required field '%s'\")"
                            % field_name
                        )
            self.emit()

            # generate setter for field
            self.emit('@{}.setter'.format(field_name_reserved_check))
            self.emit('def {}(self, val):'.format(field_name_reserved_check))
            with self.indent():
                if field.data_type.nullable:
                    self.emit('if val is None:')
                    with self.indent():
                        self.emit('del self.{}'.format(field_name_reserved_check))
                        self.emit('return')
                if is_composite_type(field.data_type):
                    self.emit('self._%s_validator.validate_type_only(val)'
                                   % field_name)
                else:
                    self.emit('val = self._{}_validator.validate(val)'.format(field_name))
                self.emit('self._{}_value = val'.format(field_name))
                self.emit('self._{}_present = True'.format(field_name))
            self.emit()

            # generate deleter for field
            self.emit('@{}.deleter'.format(field_name_reserved_check))
            self.emit('def {}(self):'.format(field_name_reserved_check))
            with self.indent():
                self.emit('self._{}_value = None'.format(field_name))
                self.emit('self._{}_present = False'.format(field_name))
            self.emit()

    def _generate_struct_class_repr(self, data_type):
        """
        Generates something like:

            def __repr__(self):
                return 'Employee(first_name={!r}, last_name={!r}, age={!r})'.format(
                    self._first_name_value,
                    self._last_name_value,
                    self._age_value,
                )
        """
        self.emit('def __repr__(self):')
        with self.indent():
            if data_type.all_fields:
                constructor_kwargs_fmt = ', '.join(
                    '{}={{!r}}'.format(self.lang.format_variable(f.name, True))
                    for f in data_type.all_fields)
                self.emit("return '{}({})'.format(".format(
                    self._class_name_for_data_type(data_type),
                    constructor_kwargs_fmt,
                ))
                with self.indent():
                    for f in data_type.all_fields:
                        self.emit("self._{}_value,".format(self.lang.format_variable(f.name)))
                self.emit(")")
            else:
                self.emit("return '%s()'"
                               % self._class_name_for_data_type(data_type))
        self.emit()

    #
    # Tagged Union Types
    #

    def _class_declaration_for_union(self, data_type):
        assert is_union_type(data_type), \
            'Expected union, got %r' % type(data_type)
        if data_type.subtype:
            extends = self._class_name_for_data_type(data_type.subtype)
        else:
            extends = 'object'
        return 'class {}({}):'.format(
            self._class_name_for_data_type(data_type), extends)

    def _generate_union_class(self, data_type):
        """Defines a Python class that represents a union in Babel."""
        self.emit(self._class_declaration_for_union(data_type))
        with self.indent():
            if data_type.doc:
                self.emit('"""')
                self.emit_wrapped_text(
                    self.process_doc(data_type.doc, self._docf))
                self.emit()
                for field in data_type.fields:
                    if is_void_type(field.data_type):
                        ivar_doc = ':ivar {}: {}'.format(
                            self.lang.format_variable(field.name),
                            self.process_doc(field.doc, self._docf))
                    elif is_composite_type(field.data_type):
                        ivar_doc = ':ivar {} {}: {}'.format(
                            self.lang.format_class(field.data_type.name),
                            self.lang.format_variable(field.name),
                            self.process_doc(field.doc, self._docf))
                    else:
                        ivar_doc = ':ivar {} {}: {}'.format(
                            self._python_type_mapping(field.data_type),
                            self.lang.format_variable(field.name), field.doc)
                    self.emit_wrapped_text(ivar_doc, subsequent_prefix='    ')
                self.emit('"""')
            self.emit()

            self._generate_union_class_slots()
            self._generate_union_class_vars(data_type)
            self._generate_union_class_init(data_type)
            self._generate_union_class_variant_creators(data_type)
            self._generate_union_class_is_set(data_type)
            self._generate_union_class_get_helpers(data_type)
            self._generate_union_class_repr(data_type)
        self._generate_union_class_symbol_creators(data_type)

    def _generate_union_class_slots(self):
        """Creates a slots declaration for union classes.

        Slots are an optimization in Python that reduce the memory footprint
        of instances since attributes cannot be added after declaration.

        Unions only ever have two attributes: _tag and _value.
        """
        # TODO(kelkabany): Possible optimization is to remove _value if a
        # union is composed of only symbols.
        self.emit("__slots__ = ['_tag', '_value']")
        self.emit()

    def _generate_union_class_vars(self, data_type):
        """
        Each class has a class attribute for each field specifying its data type.
        If a catch all field exists, it's specified as a _catch_all_ attribute.
        """
        lineno = self.lineno
        for field in data_type.fields:
            field_name = self.lang.format_variable(field.name)
            validator_name = self._generate_validator_constructor(field.data_type)
            self.emit('_{}_validator = {}'.format(field_name,
                                                        validator_name))
        if data_type.catch_all_field:
            self.emit("_catch_all = '%s'" % data_type.catch_all_field.name)
        elif not data_type.subtype:
            self.emit('_catch_all = None')

        # Generate stubs for class variables so that IDEs like PyCharms have an
        # easier time detecting their existence.
        for field in data_type.fields:
            if is_void_type(field.data_type):
                field_name = self.lang.format_variable(field.name)
                self.emit('# Attribute is overwritten below the class definition')
                self.emit('{} = None'.format(field_name))

        if lineno != self.lineno:
            self.emit()

        self._generate_union_class_tagmap_for_reflection(data_type)

    def _generate_union_class_tagmap_for_reflection(self, data_type):
        with self.block('_tagmap ='):
            for field in data_type.fields:
                var_name = self.lang.format_variable(field.name)
                validator_name = '_{0}_validator'.format(var_name)
                self.emit("'{}': {},".format(var_name, validator_name))
        if data_type.subtype:
            self.emit('_tagmap.update({}._tagmap)'.format(
                self._class_name_for_data_type(data_type.subtype)))
        self.emit()

    def _generate_union_class_init(self, data_type):
        """Generates the __init__ method for the class. The tag should be
        specified as a string, and the value will be validated with respect
        to the tag."""
        self.emit('def __init__(self, tag, value=None):')
        with self.indent():
            self.emit("assert tag in self._tagmap, 'Invalid tag %r.' % tag")
            self.emit('validator = self._tagmap[tag]')
            self.emit('if isinstance(validator, bv.Void):')
            with self.indent():
                self.emit(
                    "assert value is None, 'Void type union member must have None value.'")
            self.emit('elif isinstance(validator, (bv.Struct, bv.Union)):')
            with self.indent():
                self.emit('validator.validate_type_only(value)')
            self.emit('else:')
            with self.indent():
                self.emit('validator.validate(value)')
            self.emit('self._tag = tag')
            self.emit('self._value = value')
            self.emit()

    def _generate_union_class_variant_creators(self, data_type):
        """
        Each non-symbol, non-any variant has a corresponding class method that
        can be used to construct a union with that variant selected.
        """
        for field in data_type.fields:
            if not is_void_type(field.data_type):
                field_name = self.lang.format_method(field.name)
                field_name_reserved_check = self.lang.format_method(field.name, True)
                self.emit('@classmethod')
                self.emit('def {}(cls, val):'.format(field_name_reserved_check))
                with self.indent():
                    self.emit("return cls('{}', val)".format(field_name))
                self.emit()

    def _generate_union_class_is_set(self, data_type):
        for field in data_type.fields:
            field_name = self.lang.format_method(field.name)
            self.emit('def is_{}(self):'.format(field_name))
            with self.indent():
                self.emit("return self._tag == '{}'".format(field_name))
            self.emit()

    def _generate_union_class_get_helpers(self, data_type):
        """
        These are the getters used to access the value of a variant, once
        the tag has been switched on.
        """
        for field in data_type.fields:
            field_name = self.lang.format_method(field.name)

            if not is_void_type(field.data_type):
                # generate getter for field
                self.emit('def get_{}(self):'.format(field_name))
                with self.indent():
                    self.emit('if not self.is_{}():'.format(field_name))
                    with self.indent():
                        self.emit(
                            'raise AttributeError("tag \'{}\' not set")'.format(
                                field_name))
                    self.emit('return self._value')
                self.emit()

    def _generate_union_class_repr(self, data_type):
        """
        The __repr__() function will return a string of the class name, and
        the selected tag.
        """
        self.emit('def __repr__(self):')
        with self.indent():
            self.emit("return '{}(%r)' % self._tag".format(
                self._class_name_for_data_type(data_type),
            ))
        self.emit()

    def _generate_union_class_symbol_creators(self, data_type):
        """
        Class attributes that represent a symbol are set after the union class
        definition.
        """
        class_name = self.lang.format_class(data_type.name)
        lineno = self.lineno
        for field in data_type.fields:
            if is_void_type(field.data_type):
                field_name = self.lang.format_method(field.name)
                self.emit("{0}.{1} = {0}('{1}')".format(class_name, field_name))
        if lineno != self.lineno:
            self.emit()
